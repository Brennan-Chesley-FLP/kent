{% extends "base.html" %}

{% block title %}Dashboard - LocalDevDriver{% endblock %}

{% block content %}
<div class="dashboard">
    <h1>Scraper Runs</h1>

    <div class="actions">
        <button id="scan-btn" class="btn btn-secondary">Scan for New Runs</button>
        <button id="new-run-btn" class="btn btn-primary">New Run</button>
    </div>

    <div class="run-sections">
        <!-- Running -->
        <section class="run-section">
            <h2>Running <span id="running-count" class="badge">0</span></h2>
            <div id="running-runs" class="run-grid">
                <p class="empty-state">No running scrapers</p>
            </div>
        </section>

        <!-- Ready (Stopped or Unloaded - can be resumed) -->
        <section class="run-section">
            <h2>Ready <span id="ready-count" class="badge">0</span></h2>
            <div id="ready-runs" class="run-grid">
                <p class="empty-state">No runs ready to resume</p>
            </div>
        </section>
    </div>
</div>

<!-- New Run Modal -->
<div id="new-run-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Create New Run</h2>
            <button class="close-btn" onclick="closeModal()">&times;</button>
        </div>
        <form id="new-run-form">
            <div class="form-section">
                <h3>Basic Configuration</h3>

                <div class="form-group">
                    <label for="run-id">Run ID</label>
                    <input type="text" id="run-id" name="run_id" required
                           placeholder="e.g., nyscef-2024-01">
                    <small>Unique identifier for this run</small>
                </div>

                <div class="form-group">
                    <label for="scraper-select">Scraper</label>
                    <select id="scraper-select" name="scraper_path" required>
                        <option value="">Select a scraper...</option>
                    </select>
                    <small>Select the scraper to run</small>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="workers">Workers</label>
                        <input type="number" id="workers" name="num_workers"
                               value="1" min="1" max="10">
                    </div>
                </div>
            </div>

            <div class="form-section" id="speculative-section" style="display: none;">
                <h3>Speculative Scraping</h3>
                <small class="section-help">Configure starting IDs for speculative request steps</small>
                <div id="speculative-container">
                    <!-- Dynamic speculative step fields will be inserted here -->
                </div>
            </div>

            <div class="form-section" id="params-section" style="display: none;">
                <h3>Scraper Parameters</h3>
                <div id="params-container">
                    <!-- Dynamic parameter fields will be inserted here -->
                </div>
            </div>

            <div class="form-actions">
                <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button type="submit" class="btn btn-primary">Create Run</button>
            </div>
        </form>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Scrapers data
let scrapersData = [];

// Run card template
function createRunCard(run) {
    const statusColors = {
        'running': 'status-running',
        'loaded': 'status-loaded',
        'unloaded': 'status-unloaded',
        'stopped': 'status-stopped',
        'stopping': 'status-stopping'
    };

    const statusClass = statusColors[run.status] || 'status-unknown';
    const isReady = ['unloaded', 'loaded', 'stopped'].includes(run.status);

    return `
        <div class="run-card" data-run-id="${run.run_id}">
            <div class="run-header">
                <h3><a href="/runs/${run.run_id}">${run.run_id}</a></h3>
                <span class="status ${statusClass}">${run.status}</span>
            </div>
            <div class="run-meta">
                <p>Created: ${new Date(run.created_at).toLocaleString()}</p>
                ${run.started_at ? `<p>Started: ${new Date(run.started_at).toLocaleString()}</p>` : ''}
            </div>
            <div class="run-actions">
                ${isReady ? `<button onclick="resumeRun('${run.run_id}')" class="btn btn-sm btn-primary">Resume</button>` : ''}
                ${run.status === 'running' ? `<button onclick="stopRun('${run.run_id}')" class="btn btn-sm btn-danger">Stop</button>` : ''}
                ${isReady ? `<button onclick="deleteRun('${run.run_id}')" class="btn btn-sm btn-danger">Delete</button>` : ''}
            </div>
        </div>
    `;
}

// Load runs from API
async function loadRuns() {
    try {
        const response = await fetch('/api/runs');
        const data = await response.json();

        const running = data.runs.filter(r => r.status === 'running' || r.status === 'stopping');
        // "Ready" includes loaded, stopped, and unloaded - all can be resumed
        const ready = data.runs.filter(r => ['unloaded', 'loaded', 'stopped'].includes(r.status));

        document.getElementById('running-count').textContent = running.length;
        document.getElementById('ready-count').textContent = ready.length;

        renderRuns('running-runs', running);
        renderRuns('ready-runs', ready);
    } catch (error) {
        console.error('Failed to load runs:', error);
    }
}

function renderRuns(containerId, runs) {
    const container = document.getElementById(containerId);
    if (runs.length === 0) {
        container.innerHTML = '<p class="empty-state">None</p>';
    } else {
        container.innerHTML = runs.map(createRunCard).join('');
    }
}

// Load scrapers from API
async function loadScrapers() {
    try {
        const response = await fetch('/api/scrapers');
        const data = await response.json();
        scrapersData = data.scrapers;

        const select = document.getElementById('scraper-select');
        select.innerHTML = '<option value="">Select a scraper...</option>';

        for (const scraper of scrapersData) {
            const option = document.createElement('option');
            option.value = scraper.full_path;
            option.textContent = `${scraper.class_name} (${scraper.status})`;
            option.dataset.scraperData = JSON.stringify(scraper);
            select.appendChild(option);
        }
    } catch (error) {
        console.error('Failed to load scrapers:', error);
    }
}

// Build speculative steps form for selected scraper
function buildSpeculativeForm(scraper) {
    const container = document.getElementById('speculative-container');
    const section = document.getElementById('speculative-section');

    // Collect speculative steps from either old or new schema
    let speculativeSteps = [];

    if (scraper.entry_schema && scraper.entry_schema.entries) {
        // New @entry system: find entries with speculative=true
        for (const [name, entry] of Object.entries(scraper.entry_schema.entries)) {
            if (entry.speculative) {
                speculativeSteps.push({
                    name: name,
                    default_starting_id: 1,
                    highest_observed: entry.highest_observed || 1,
                    largest_observed_gap: entry.largest_observed_gap || 10,
                });
            }
        }
    } else if (scraper.speculative_steps && scraper.speculative_steps.length > 0) {
        // Old system
        speculativeSteps = scraper.speculative_steps;
    }

    if (speculativeSteps.length === 0) {
        section.style.display = 'none';
        container.innerHTML = '';
        return;
    }

    section.style.display = 'block';
    container.innerHTML = '';

    for (const step of speculativeSteps) {
        const stepDiv = document.createElement('div');
        stepDiv.className = 'speculative-step';
        const highestInfo = step.highest_observed ? ` (highest observed: ${step.highest_observed})` : '';
        stepDiv.innerHTML = `
            <div class="model-header">
                <label class="checkbox-label">
                    <input type="checkbox"
                           id="speculative-${step.name}-enabled"
                           name="speculative.${step.name}.enabled"
                           checked>
                    <strong>${step.name}</strong>${highestInfo}
                    <small class="entry-return-type">speculative</small>
                </label>
            </div>
            <div class="form-row" id="speculative-${step.name}-fields">
                <div class="form-group">
                    <label for="speculative-${step.name}-start">Starting ID</label>
                    <input type="number"
                           id="speculative-${step.name}-start"
                           name="speculative.${step.name}.start"
                           value="${step.default_starting_id}"
                           min="1"
                           placeholder="Starting ID">
                    <small>ID to begin scanning from</small>
                </div>
                <div class="form-group">
                    <label for="speculative-${step.name}-threshold">Threshold</label>
                    <input type="number"
                           id="speculative-${step.name}-threshold"
                           name="speculative.${step.name}.threshold"
                           value="0"
                           min="0"
                           placeholder="Threshold">
                    <small>IDs &le; threshold always continue</small>
                </div>
                <div class="form-group">
                    <label for="speculative-${step.name}-speculation">Speculation</label>
                    <input type="number"
                           id="speculative-${step.name}-speculation"
                           name="speculative.${step.name}.speculation"
                           value="${step.largest_observed_gap || 5}"
                           min="1"
                           placeholder="Speculation limit">
                    <small>Failed attempts above threshold before stopping</small>
                </div>
            </div>
        `;

        // Toggle fields when checkbox changes
        const checkbox = stepDiv.querySelector(`#speculative-${step.name}-enabled`);
        const fieldsDiv = stepDiv.querySelector(`#speculative-${step.name}-fields`);
        checkbox.addEventListener('change', () => {
            fieldsDiv.style.display = checkbox.checked ? '' : 'none';
        });

        container.appendChild(stepDiv);
    }
}

// Build parameter form for selected scraper
function buildParamsForm(scraper) {
    const container = document.getElementById('params-container');
    const section = document.getElementById('params-section');

    // Also build speculative form
    buildSpeculativeForm(scraper);

    // Use new @entry schema if available
    if (scraper.entry_schema && scraper.entry_schema.entries) {
        buildEntrySchemaForm(scraper.entry_schema, container, section);
        return;
    }

    // Fall back to old models-based form
    if (!scraper.models || scraper.models.length === 0) {
        section.style.display = 'none';
        container.innerHTML = '';
        return;
    }

    section.style.display = 'block';
    container.innerHTML = '';

    for (const model of scraper.models) {
        const modelDiv = document.createElement('div');
        modelDiv.className = 'model-section';
        modelDiv.innerHTML = `
            <div class="model-header">
                <label class="checkbox-label">
                    <input type="checkbox"
                           id="model-${model.name}-enabled"
                           name="models.${model.name}.enabled"
                           checked>
                    <strong>${model.name}</strong>
                </label>
            </div>
            <div class="model-fields" id="model-${model.name}-fields">
            </div>
        `;

        const fieldsDiv = modelDiv.querySelector('.model-fields');

        for (const field of model.fields) {
            const fieldDiv = document.createElement('div');
            fieldDiv.className = 'form-group field-group';

            let fieldHtml = `<label>${field.name}</label>`;

            if (field.filter_type === 'DateRange') {
                fieldHtml += `
                    <div class="date-range">
                        <input type="date"
                               name="models.${model.name}.fields.${field.name}.gte"
                               placeholder="From">
                        <span>to</span>
                        <input type="date"
                               name="models.${model.name}.fields.${field.name}.lte"
                               placeholder="To">
                    </div>
                `;
            } else if (field.filter_type === 'SetFilter') {
                fieldHtml += `
                    <input type="text"
                           name="models.${model.name}.fields.${field.name}.values"
                           placeholder="Comma-separated values">
                    <small>Enter values separated by commas</small>
                `;
            } else if (field.filter_type === 'UniqueMatch') {
                fieldHtml += `
                    <input type="text"
                           name="models.${model.name}.fields.${field.name}.value"
                           placeholder="Exact value">
                `;
            }

            if (field.description) {
                fieldHtml += `<small>${field.description}</small>`;
            }

            fieldDiv.innerHTML = fieldHtml;
            fieldsDiv.appendChild(fieldDiv);
        }

        // Toggle fields when checkbox changes
        const checkbox = modelDiv.querySelector(`#model-${model.name}-enabled`);
        checkbox.addEventListener('change', () => {
            fieldsDiv.style.display = checkbox.checked ? 'block' : 'none';
        });

        container.appendChild(modelDiv);
    }
}

// Build form from new @entry JSON Schema
function buildEntrySchemaForm(entrySchema, container, section) {
    const entries = entrySchema.entries;
    const defs = entrySchema.$defs || {};

    // Filter to non-speculative entries (show even if no parameters,
    // so users can enable/disable them)
    const paramEntries = Object.entries(entries).filter(([name, entry]) =>
        !entry.speculative
    );

    if (paramEntries.length === 0) {
        section.style.display = 'none';
        container.innerHTML = '';
        return;
    }

    section.style.display = 'block';
    container.innerHTML = '';

    for (const [entryName, entry] of paramEntries) {
        const entryDiv = document.createElement('div');
        entryDiv.className = 'model-section';
        entryDiv.innerHTML = `
            <div class="model-header">
                <label class="checkbox-label">
                    <input type="checkbox"
                           id="entry-${entryName}-enabled"
                           name="entry.${entryName}.enabled"
                           checked>
                    <strong>${entryName}</strong>
                    <small class="entry-return-type">â†’ ${entry.returns}</small>
                </label>
            </div>
            <div class="model-fields" id="entry-${entryName}-fields">
            </div>
        `;

        const fieldsDiv = entryDiv.querySelector('.model-fields');
        const props = entry.parameters.properties || {};

        for (const [paramName, paramSchema] of Object.entries(props)) {
            const fieldDiv = document.createElement('div');
            fieldDiv.className = 'form-group field-group';

            // Resolve $ref to get actual schema
            let resolvedSchema = paramSchema;
            if (paramSchema.$ref) {
                const refName = paramSchema.$ref.replace('#/$defs/', '');
                resolvedSchema = defs[refName] || paramSchema;
            }

            let fieldHtml = `<label>${paramName}</label>`;
            fieldHtml += buildJsonSchemaInput(entryName, paramName, resolvedSchema, defs);

            fieldDiv.innerHTML = fieldHtml;
            fieldsDiv.appendChild(fieldDiv);
        }

        // Toggle fields when checkbox changes
        const checkbox = entryDiv.querySelector(`#entry-${entryName}-enabled`);
        checkbox.addEventListener('change', () => {
            fieldsDiv.style.display = checkbox.checked ? 'block' : 'none';
        });

        container.appendChild(entryDiv);
    }
}

// Build input element from JSON Schema type
function buildJsonSchemaInput(entryName, paramName, schema, defs) {
    if (schema.type === 'string' && schema.format === 'date') {
        return `<input type="date" name="entry.${entryName}.params.${paramName}">`;
    }
    if (schema.type === 'string') {
        return `<input type="text" name="entry.${entryName}.params.${paramName}" placeholder="${paramName}">`;
    }
    if (schema.type === 'integer') {
        return `<input type="number" name="entry.${entryName}.params.${paramName}" placeholder="${paramName}">`;
    }
    if (schema.type === 'object' && schema.properties) {
        // Render nested object (Pydantic model) as grouped fields
        let html = '<div class="nested-model">';
        for (const [propName, propSchema] of Object.entries(schema.properties)) {
            let resolved = propSchema;
            if (propSchema.$ref) {
                const refName = propSchema.$ref.replace('#/$defs/', '');
                resolved = defs[refName] || propSchema;
            }
            html += `<div class="form-group">`;
            html += `<label>${propName}</label>`;
            html += buildJsonSchemaInput(entryName, `${paramName}.${propName}`, resolved, defs);
            html += `</div>`;
        }
        html += '</div>';
        return html;
    }
    // Fallback
    return `<input type="text" name="entry.${entryName}.params.${paramName}" placeholder="${paramName}">`;
}

// Modal functions
function openModal() {
    document.getElementById('new-run-modal').classList.add('active');
    document.getElementById('new-run-form').reset();
    document.getElementById('params-section').style.display = 'none';
    document.getElementById('params-container').innerHTML = '';
    document.getElementById('speculative-section').style.display = 'none';
    document.getElementById('speculative-container').innerHTML = '';
}

function closeModal() {
    document.getElementById('new-run-modal').classList.remove('active');
}

// Handle scraper selection
document.getElementById('scraper-select').addEventListener('change', (e) => {
    const option = e.target.selectedOptions[0];
    if (option && option.dataset.scraperData) {
        const scraper = JSON.parse(option.dataset.scraperData);
        buildParamsForm(scraper);
    } else {
        document.getElementById('params-section').style.display = 'none';
        document.getElementById('params-container').innerHTML = '';
        document.getElementById('speculative-section').style.display = 'none';
        document.getElementById('speculative-container').innerHTML = '';
    }
});

// Handle form submission
document.getElementById('new-run-form').addEventListener('submit', async (e) => {
    e.preventDefault();

    const formData = new FormData(e.target);

    // Build request body
    const body = {
        run_id: formData.get('run_id'),
        scraper_path: formData.get('scraper_path'),
        num_workers: parseInt(formData.get('num_workers')),
        params: { models: {}, speculative: {} },
        speculation_config: {}
    };

    // Check if this scraper uses the new @entry system
    const selectedOption = document.getElementById('scraper-select').selectedOptions[0];
    const scraperData = selectedOption ? JSON.parse(selectedOption.dataset.scraperData || '{}') : {};
    const usesEntrySchema = !!(scraperData.entry_schema && scraperData.entry_schema.entries);

    // Build seed_params for new @entry system
    if (usesEntrySchema) {
        body.seed_params = [];

        // Collect entry params from form, unflattening dotted keys
        // into nested objects (e.g. "date_range.start" -> {date_range: {start: val}})
        const entryParams = {};
        for (const [key, value] of formData.entries()) {
            if (key.startsWith('entry.')) {
                const parts = key.split('.');
                // entry.<entryName>.params.<paramName>[.<nested>...]
                const entryName = parts[1];
                if (parts[2] === 'params' && value) {
                    if (!entryParams[entryName]) entryParams[entryName] = {};
                    const paramParts = parts.slice(3);
                    let target = entryParams[entryName];
                    for (let i = 0; i < paramParts.length - 1; i++) {
                        if (!target[paramParts[i]]) target[paramParts[i]] = {};
                        target = target[paramParts[i]];
                    }
                    target[paramParts[paramParts.length - 1]] = value;
                }
            }
        }

        // Check which entries are enabled (non-speculative and speculative)
        const entries = scraperData.entry_schema.entries;
        for (const [entryName, entry] of Object.entries(entries)) {
            if (entry.speculative) {
                // Include enabled speculative entries in seed_params
                // so the driver knows which speculative entries to run
                const specCheckbox = document.getElementById(`speculative-${entryName}-enabled`);
                if (specCheckbox && specCheckbox.checked) {
                    body.seed_params.push({[entryName]: {}});
                }
                continue;
            }

            // Check if entry is enabled (checkbox)
            const checkbox = e.target.querySelector(`#entry-${entryName}-enabled`);
            if (checkbox && !checkbox.checked) continue;

            const params = entryParams[entryName] || {};

            // Convert numeric params
            for (const [pName, pSchema] of Object.entries(entry.parameters.properties || {})) {
                if (pSchema.type === 'integer' && params[pName]) {
                    params[pName] = parseInt(params[pName]);
                }
            }

            body.seed_params.push({[entryName]: params});
        }
    }

    // Collect which speculative steps are disabled
    const disabledSpecSteps = new Set();
    document.querySelectorAll('[id^="speculative-"][id$="-enabled"]').forEach(cb => {
        if (!cb.checked) {
            // Extract step name from id: speculative-<name>-enabled
            const name = cb.id.replace('speculative-', '').replace('-enabled', '');
            disabledSpecSteps.add(name);
        }
    });

    // Process params from form (old system and speculative config)
    for (const [key, value] of formData.entries()) {
        // Handle speculative step configuration
        // Format: speculative.<stepName>.<property> where property is start, threshold, or speculation
        if (key.startsWith('speculative.')) {
            const parts = key.split('.');
            const stepName = parts[1];
            const prop = parts[2];

            // Skip disabled speculative steps
            if (prop === 'enabled') continue;
            if (disabledSpecSteps.has(stepName)) continue;

            if (value) {
                if (prop === 'start') {
                    // Starting ID goes in params.speculative
                    body.params.speculative[stepName] = parseInt(value);
                } else if (prop === 'threshold' || prop === 'speculation') {
                    // Threshold and speculation go in speculation_config
                    if (!body.speculation_config[stepName]) {
                        body.speculation_config[stepName] = {};
                    }
                    body.speculation_config[stepName][prop] = parseInt(value);
                }
            }
        }
        else if (key.startsWith('models.')) {
            const parts = key.split('.');
            // models.<ModelName>.enabled or models.<ModelName>.fields.<fieldName>.<prop>
            const modelName = parts[1];

            if (!body.params.models[modelName]) {
                body.params.models[modelName] = { enabled: true, fields: {} };
            }

            if (parts[2] === 'enabled') {
                body.params.models[modelName].enabled = value === 'on';
            } else if (parts[2] === 'fields' && parts[3] && parts[4]) {
                const fieldName = parts[3];
                const prop = parts[4];

                if (!body.params.models[modelName].fields[fieldName]) {
                    body.params.models[modelName].fields[fieldName] = {};
                }

                if (prop === 'values' && value) {
                    // Split comma-separated values
                    body.params.models[modelName].fields[fieldName][prop] =
                        value.split(',').map(v => v.trim()).filter(v => v);
                } else if (value) {
                    body.params.models[modelName].fields[fieldName][prop] = value;
                }
            }
        }
    }

    // Handle unchecked checkboxes (not in formData) - old system only
    if (!usesEntrySchema) {
        const checkboxes = e.target.querySelectorAll('input[type="checkbox"][name$=".enabled"]');
        for (const checkbox of checkboxes) {
            const parts = checkbox.name.split('.');
            const modelName = parts[1];
            if (!checkbox.checked) {
                if (!body.params.models[modelName]) {
                    body.params.models[modelName] = { enabled: false, fields: {} };
                } else {
                    body.params.models[modelName].enabled = false;
                }
            }
        }
    }

    // Clean up empty sections
    if (Object.keys(body.speculation_config).length === 0) {
        delete body.speculation_config;
    }
    if (usesEntrySchema) {
        // New system doesn't use old params format
        delete body.params;
    }

    try {
        const response = await fetch('/api/runs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to create run');
        }

        closeModal();
        loadRuns();
        alert(`Run '${body.run_id}' created successfully!`);
    } catch (error) {
        alert('Error creating run: ' + error.message);
    }
});

// Actions
async function scanRuns() {
    try {
        await fetch('/api/runs/scan', { method: 'POST' });
        loadRuns();
    } catch (error) {
        alert('Failed to scan: ' + error.message);
    }
}

async function resumeRun(runId) {
    try {
        const response = await fetch(`/api/runs/${runId}/resume`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})  // Use defaults (scraper from DB)
        });
        if (response.ok) {
            loadRuns();
        } else {
            const data = await response.json();
            alert('Failed to resume run: ' + (data.detail || 'Unknown error'));
        }
    } catch (error) {
        alert('Failed to resume run: ' + error.message);
    }
}

async function stopRun(runId) {
    try {
        await fetch(`/api/runs/${runId}/stop`, { method: 'POST' });
        loadRuns();
    } catch (error) {
        alert('Failed to stop: ' + error.message);
    }
}

async function deleteRun(runId) {
    if (!confirm(`Delete run "${runId}"? This cannot be undone.`)) return;
    try {
        await fetch(`/api/runs/${runId}`, { method: 'DELETE' });
        loadRuns();
    } catch (error) {
        alert('Failed to delete: ' + error.message);
    }
}

// Event listeners
document.getElementById('scan-btn').addEventListener('click', scanRuns);
document.getElementById('new-run-btn').addEventListener('click', openModal);

// Close modal on outside click
document.getElementById('new-run-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('modal')) {
        closeModal();
    }
});

// Initial load
loadRuns();
loadScrapers();

// Auto-refresh every 5 seconds
setInterval(loadRuns, 5000);
</script>
{% endblock %}
